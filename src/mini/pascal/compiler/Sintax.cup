package mini.pascal.compiler;

import java_cup.runtime.*;
import java.io.FileReader;
import mini.pascal.ast.*;

parser code {:

	public PascalProgram root = null;

	public void report_error(String message, Object info) {
		StringBuilder m = new StringBuilder("Sintax Error");
		if (info instanceof java_cup.runtime.Symbol) {
			java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
			if (s.left >= 0) {
				m.append(" at line "+(s.left+1));
				if (s.right >= 0)
					m.append(", column "+(s.right+1));
			}
		}
		m.append(" : "+message);
		System.err.println(m);
	}

	public void report_fatal_error(String message, Object info) {
		report_error(message, info);
		System.exit(1);
	}

	public void syntax_error(Symbol cur_token) {
		report_error("on Token "+ cur_token.value, cur_token);
	}

	public static void main(String[] args){
		try {
			Parser asin = new Parser(
				new Lexer( new FileReader(args[0])));
			Object result = asin.parse().value;
		} catch (Exception ex) {
			ex.printStackTrace();
		}
	}
	:};

	terminal  PROGRAM, BEGIN, END, AND, ARRAY, DIV, DO, ELSE,
	IF, NOT, OF, OR, PROCEDURE, THEN, VAR, WHILE, QUOTE,
	LEFT_PAR, RIGHT_PAR, LEFT_BRACKET, RIGHT_BRACKET,
	SEMICOLON, COLON, COMMA, DOT, ASIGN, PLUS, MINUS,
	DIVIDE, PRODUCT, XOR, MOD, EQUALS, NOT_EQUAL,
	GREATER_THAN, LESS_THAN, GREATER_EQUALS, LESS_EQUAL,
	INTEGER, ID, STRING, CHAR, LEFT_KEY, WRITE_LN, READ_LN,
	BOOLEAN, INT_CONST, TRUE, FALSE, CHAR_CONS, RIGHT_KEY;
	terminal String STRING_LITERAL;

	non terminal pascalProgram, block, variableDeclarationPart, variableDeclarationList, variableDeclaration, identifierList, 
	type, arrayType, indexRange, simpleType, statementPart, compoundStatement, statementList, statement, procedureIdentifier, constant, simpleStatement, assignmentStatement, 
	procedureStatement, readStatement, inputVariableList, inputVariable, writeStatement, outputValueList, outputValue, structuredStatement, 
	ifStatement, whileStatement, expression, simpleExpressionList, simpleExpression, term, factor, relationalOperator, sign, addingOperator,
	multiplyingOperator, variable, indexedVariable, arrayVariable, entireVariable, variableIdentifier, empty;

	precedence left OR ;
	precedence left AND ;
	precedence nonassoc EQUALS, NOT_EQUAL, LESS_THAN, GREATER_THAN, LESS_EQUAL, GREATER_EQUALS ;
	precedence left PLUS, MINUS ;
	precedence left PRODUCT, DIVIDE ;
	precedence nonassoc NOT ;
	precedence left DOT, LEFT_BRACKET, RIGHT_BRACKET, LEFT_PAR, RIGHT_PAR ;
	precedence right ELSE;
	start with pascalProgram;

	pascalProgram::= PROGRAM:pro ID:id SEMICOLON:sc block:block DOT:dt {:
		PascalProgram r = new PascalProgram((String) pro, (String) id, block, (String) sc, (String) dt);
		RESULT = r;
		
		:} 
		;

	block::= variableDeclarationPart:vdp statementPart:sp {:
		Block r = new Block(vdp, sp);
		RESULT = r;
		
		:}
		;

	variableDeclarationPart::= VAR:var variableDeclarationList:vdl {:
		VariableDeclarationPart r = new VariableDeclarationPart((String)var, vdl);
		RESULT = r;
		:}
		|
	empty:empty {:
		:}
		;

	variableDeclarationList::= variableDeclaration:vd {:
			VariableDeclaration r = new VariableDeclaration(vd);
			RESULT = r;
			:}
			|
		variableDeclarationList:vdl variableDeclaration:vd{:
			VariableDeclaration r = new VariableDeclaration(vdl, il, (String) c, t, (String)sc);
			RESULT = r;
			:}
			;

	variableDeclaration::= identifierList:il COLON:c type:t SEMICOLON:sc {:
			VariableDeclaration r = new VariableDeclaration( il, (String) c, t, (String)sc);
			RESULT = r;
		:};


	identifierList::= ID:id {:
			IdentifierList r = new IdentifierList((String) id);
			RESULT = r;
			:}
			|
		identifierList:il COMMA:c ID:id {:
			IdentifierList r = new IdentifierList((String) id, (String) c, il);
			RESULT = r;
			:}
			;
	type::= simpleType:st {:
		Type r = new Type(st);
		RESULT = r;
		:}
		| 
		arrayType:at {:
		Type r = new Type(at);
		RESULT = r;
			:}
		;

	arrayType::= ARRAY:arr LEFT_BRACKET:lb indexRange:ir RIGHT_BRACKET:rb OF:of simpleType:st {:
			ArrayType r = new ArrayType((String)arr, (String)lb, ir, (String)rb, (String)of, st);
			RESULT = r;
		:}
		;

	indexRange::= INTEGER:integer1 DOT:dt1 DOT:dt2 INTEGER:integer2 {:
			IndexRange r = new IndexRange((String)integer1, (String)dt1, (String)dt2, (String)integer2);
			RESULT = r;
		:}
 	;
	simpleType::= ID:id {:
		SimpleType r = new SimpleType((String)id);
		RESULT = r;
		:}
		;

	statementPart::= compoundStatement:cs {:
		StatementPart r = new StatementPart(cs);
		RESULT = r;
		:}
		;

	compoundStatement::= BEGIN:bg statementList:sl END:end{:
		CompoundStatement r = new CompoundStatement((String)bg, sl, (String)end);
		RESULT = r;
		:}
		;
	statementList::= statement:stm {:
			StatementList r = new StatementList(stm);
			RESULT = r;
				:}
	|
	statementList:sl SEMICOLON:sc statement:stm  {:
			StatementList r = new StatementList(sl, (String)sc, stm);
			RESULT = r;
			:}
	;
	statement::= ID:ss {:
			Statement r = new Statement(ss);
			RESULT = r;
		:}
		|
		structuredStatement:ss {:
			Statement r = new Statement(ss);
			RESULT = r;
		:}
		;

	simpleStatement::= assignmentStatement:as {:
			Statement r = new Statement(as);
			RESULT = r;
		:}
		|
	ID:ps {:
			ProcedureStatement r = new ProcedureStatement(ps);
			RESULT = r;
		:}
		|
	readStatement:rs {:
			ReadStatement r = new ReadStatement(rs);
			RESULT = r;
		:}
		|
	writeStatement:ws {:
			WriteStatement r = new WriteStatement(ws);
			RESULT = r;
		:}
		;

	assignmentStatement::= variable:var {:
		AssignmentStatement r = new AssignmentStatement(var);
		RESULT r;
		:}
		|
		expression:ex {:
			AssignmentStatement r = new AssignmentStatement(ex);
			RESULT r;
		:}
		;

	procedureStatement::= ID:pi{:
		ProcedureStatement r = new ProcedureStatement(pi);
		RESULT r;
		:}
		;

	readStatement::= READ_LN:rl LEFT_BRACKET:lb inputVariableList:iv RIGHT_PAR:rp {:
		ReadStatement r = new ReadStatement((String)rl, (String)lb, iv, (String)rp);
		RESULT = r;
		:}
		;

	inputVariableList::= inputVariable:iv {:
			InputVariableList r = new InputVariableList(iv);
			RESULT = r;
		:}
		|
		inputVariableList:ivl COMMA:c inputVariable:iv {:
			InputVariableList r = new InputVariableList(ivl, (String)c, iv);
			RESULT = r;
		:}
		;

	inputVariable::= variable:v {:
			InputVariable r = new InputVariable(v);
			RESULT = r;
		:}
		;

	writeStatement::= WRITE_LN:wl LEFT_BRACKET:lb outputValueList:ovl RIGHT_PAR:rp {:
		WriteStatement r = new WriteStatement((String)wl, (String)lb, ovl, (String)rp);
		RESULT = r;
		:}
		;

	outputValueList::= outputValue:ov {:

		:}
		|
		outputValueList:ovl COMMA:c outputValue:ov{:
			OutputValueList r = new OutputValueList(ovl, (String)c, ov);
			RESULT = r;
		:}
		;

	outputValue::= expression:ex {:
			OutputValue r = new OutputValue(ex);
			RESULT = r;
		:}
		;

	structuredStatement::= compoundStatement:cs {:
		StructuredStatement r = new StructuredStatement(cs);
		RESULT = r;
		:}
		|
		ifStatement:is {:
			IfStatement r = new IfStatement(is);
			RESULT = r;
		:}
		|
		whileStatement:ws {:
			WhileStatement r = new WhileStatement(ws);
			RESULT = r;
		:}
		;

	ifStatement::= IF:is expression:ex THEN:th statement:stm {:
			IfStatement r = new IfStatement((String)is, ex,(String)th , stm);
			RESULT = r;
		:}
		|
			IF:is expression:ex THEN:th statement:stm1 ELSE:el statement:stm2 {:
				IfStatement r = new Statement((String)is, ex,(String)th , stm1, (String)el, stm2);
				RESULT = r;
		:}
		;
	whileStatement::= WHILE:wh expression:ex DO:d statement:stm {:
			WhileStatement r = new WhileStatement((String)wh, ex, (String)d, stm);
			RESULT = r;
		:}
		;

	expression::= simpleExpression:se {:
			Expression r = new Expression(se);
			RESULT = r;
		:}
		|
		simpleExpression:se1 relationalOperator:ro simpleExpression:se2{:
			Expression r = new Expression(se1, ro, se2);
			RESULT = r;
		:}
		;

	simpleExpressionList::= simpleExpression:se {:
			SimpleExpressionList r = new SimpleExpressionList(se);
			RESULT = r;
		:}
		|
		simpleExpressionList:sel simpleExpression:se {:
			SimpleExpressionList r = new SimpleExpressionList(sel, se);
			RESULT = r;
		:}
		;

	simpleExpression::= sign:sn term:tm {:
			SimpleExpression r = new SimpleExpression(sn, tm);
			RESULT = r;
		:}
		;

	term::= factor:fc {:
			Term r = new Term(fc);
			RESULT = r;
		:}
		|
		term:tm multiplyingOperator:mo factor:fc{:
			Term r = new Term(tm, mo, fc);
			RESULT = r;
		:}
		;
		
	factor::= VAR:v {:
			Factor r = new Factor(v);
			RESULT = r;
		:}
		|
		constant:c {:
			Factor r = new Factor(c);
			RESULT = r;
			:}
		|
		LEFT_PAR:lp expression:ex RIGHT_PAR:rp {:
			Factor r = new Factor((String)lp, ex, (String)rp);
			RESULT = r;
			:}
		;
	constant::= INTEGER:it {:
		Constant r = new Constant((String)it);
		RESULT r;
	:}
	|
	STRING_LITERAL:sl {:
		Constant r = new Constant((String)sl);
		RESULT r;
		:}
	|
	ID:id {:
		Constant r = new Constant((String)id);
		RESULT r;
		:}
		;
//VEREMOS
	relationalOperator::= LESS_THAN:s  {:
			RelationalOperator r = new RelationalOperator((String) s);
			RESULT = r;
			:}
	|
		LESS_EQUAL:s {:
			RelationalOperator r = new RelationalOperator((String) s);
			RESULT = r;
			:}
	|
		EQUALS:s {:
			RelationalOperator r = new RelationalOperator((String) s);
			RESULT = r;
			:}
	|
		NOT_EQUAL:s {:
			RelationalOperator r = new RelationalOperator((String) s);
			RESULT = r;
			:}
	|
		GREATER_EQUALS:s {:
			RelationalOperator r = new RelationalOperator((String) s);
			RESULT = r;
			:}
	|
		GREATER_THAN:s {:
			RelationalOperator r = new RelationalOperator((String) s);
			RESULT = r;
			:}
	;

	sign::= PLUS:pl {:
		Sign r = new Sign((String)pl);
		RESULT = r;
		:}
		|
		MINUS:mn {:
			Sign r = new Sign((String)mn);
			RESULT = r;
		:}
		|
		empty:empty {:
		:}
		;
	
	addingOperator::= PLUS:pl {:
			AddingOperator r = new AddingOperator((String)pl);
			RESULT = r;
		:}
		|
		MINUS:mn {:
			AddingOperator r = new AddingOperator((String)mn);
			RESULT = r;
		:}
		|
		OR:or {:
			AddingOperator r = new AddingOperator((String)or);
			RESULT = r;
		:}
		;	

	multiplyingOperator::= PRODUCT:pd {:
			MultiplyingOperator r = new MultiplyingOperator((String)pd);
			RESULT = r;
		:}
		|
		DIVIDE:dd {:
			MultiplyingOperator r = new MultiplyingOperator((String)dd);
			RESULT = r;
		:}
		|
		AND:an {:
			MultiplyingOperator r = new MultiplyingOperator((String)an);
			RESULT = r;
		:}
		;
	variable::= ID:ev {:
		Variable r = new Variable(ev);
		RESULT = r;
		:}
		|
		indexedVariable:iv {:
		Variable r = new Variable(iv);
		RESULT = r;
		:}
		;

	indexedVariable::= arrayVariable:av LEFT_BRACKET:lb expression:ex RIGHT_BRACKET:rb {:
			IndexedVariable r = new IndexedVariable(av, (String)lb, ex, (String)rb);
			RESULT = r;
		:}
		;

	arrayVariable::= entireVariable:ev {:
		ArrayVariable r = new ArrayVariable(ev);
		RESULT = r;
		:}
		;

	entireVariable::= ID:vi {:
		EntireVariable r = new EntireVariable(vi);
		RESULT = r;
		:}
		;

	variableIdentifier::= ID:id {:
		VariableIdentifier r = new VariableIdentifier(id);
		RESULT = r;
	:}
	;



	empty::=
	;
	}
	}
