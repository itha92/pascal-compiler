package mini.pascal.compiler;

import java_cup.runtime.*;
import java.io.FileReader;
import mini.pascal.ast.*;

parser code {:

	public PascalProgram root = null;

	public void report_error(String message, Object info) {
		StringBuilder m = new StringBuilder("Sintax Error");
		if (info instanceof java_cup.runtime.Symbol) {
			java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
			if (s.left >= 0) {
				m.append(" at line "+(s.left+1));
				if (s.right >= 0)
					m.append(", column "+(s.right+1));
			}
		}
		m.append(" : " + message);
		System.err.println(m);
	}

	public void report_fatal_error(String message, Object info) {
		report_error(message, info);
		System.exit(1);
	}

	public void syntax_error(Symbol cur_token) {
		report_error("on Token "+ cur_token.value, cur_token);
	}

	public static void main(String[] args){
		try {
			Parser asin = new Parser(
				new Lexer( new FileReader(args[0])));
			Object result = asin.parse().value;
		} catch (Exception ex) {
			ex.printStackTrace();
		}
	}
	:};

	terminal  PROGRAM, BEGIN, END, AND, ARRAY, DIV, DO, ELSE,
	IF, NOT, OF, OR, THEN, VAR, WHILE, REPEAT, UNTIL, FOR, TO,
	LEFT_PAR, RIGHT_PAR, LEFT_BRACKET, RIGHT_BRACKET, IN,
	SEMICOLON, COLON, COMMA, DOT, ASIGN, PLUS, MINUS,
	DIVIDE, PRODUCT, XOR, MOD, EQUALS, NOT_EQUAL,
	GREATER_THAN, LESS_THAN, GREATER_EQUALS, LESS_EQUAL,
	INTEGER, ID, STRING, CHAR, LEFT_KEY, WRITE_LN, READ_LN,
	BOOLEAN, INT_CONST, TRUE, FALSE, CHAR_CONS, RIGHT_KEY;
	terminal String STRING_LITERAL;

	non terminal PascalProgram pascalProgram;
	non terminal Block block;
	non terminal Object variableDeclarationPart;
	non terminal VariableDeclarationList variableDeclarationList;
	non terminal VariableDeclaration variableDeclaration;
	non terminal IdentifierList identifierList;
	non terminal Type type;
	non terminal ArrayType arrayType;
	non terminal IndexRange indexRange;
	non terminal SimpleType simpleType;
	non terminal StatementPart statementPart;
	non terminal statements;
	non terminal statement;
	non terminal variable;
	non terminal operational;
	non terminal expression;
	non terminal simpleExpression;
	non terminal Term term;
	non terminal factor;
	non terminal termOps;

	precedence left OR ;
	precedence left AND ;
	precedence nonassoc EQUALS, NOT_EQUAL, LESS_THAN, GREATER_THAN, LESS_EQUAL, GREATER_EQUALS ;
	precedence left PLUS, MINUS ;
	precedence left PRODUCT, DIVIDE ;
	precedence nonassoc NOT ;
	precedence left DOT, LEFT_BRACKET, RIGHT_BRACKET, LEFT_PAR, RIGHT_PAR ;
	precedence right ELSE;
	precedence left ID;


	start with pascalProgram;

	// program id;
	// [Block]
	// .

	pascalProgram ::= PROGRAM ID:id SEMICOLON block:block DOT {:
			PascalProgram r = new PascalProgram((String) id, block);
			RESULT = r;
		:}
	;

	// [variableDeclarationPart]
	// [statementPart]

	block::= variableDeclarationPart:vdl statements:sp {:
			Block r = new Block((VariableDeclarationList) vdl, sp);
			RESULT = r;
		:}
	;

	// VAR
	//	  [variableDeclarationList]

	variableDeclarationPart::= VAR variableDeclarationList:vdl {:
			RESULT = vdl;
		:}
	|
		{:
			VariableDeclarationList r = new VariableDeclarationList();
			RESULT = r;
		:}
	;

	//    [str, str2, str3 : string;]
	//    [char, char2, char3: char;]

	variableDeclarationList::= variableDeclaration:vd {:
			VariableDeclarationList r = new VariableDeclarationList(vd);
			RESULT = r;
		:}
	|
		variableDeclarationList:vdl variableDeclaration:vd{:
			vdl.add_declaration(vd);
			RESULT = vdl;
		:}
	;

	// variableDeclaration
	//    [num, num2, num3] : [integer];
	//    [identifierList] : [type];


	variableDeclaration::= identifierList:il COLON type:t SEMICOLON {:
			VariableDeclaration r = new VariableDeclaration(il, t);
			RESULT = r;
		:}
	;


	// [identifierList] : string
	// char, char2, char3

	identifierList::= variable:v {:
			IdentifierList r = new IdentifierList(v);
			r.add_id(id);
			RESULT = r;
		:}
	|
		identifierList:il COMMA ID:id {:
			il.add_id(id);
			RESULT = il;
		:}
	;


	// Los tipos pueden ser:
	//	str : string; (sympleType)
	// o
	//	myArray, myArray2 : Array[1..5] of Integer; (arrayType)

	type::= simpleType:st {:
			Type r = new Type(st);
			RESULT = r;
		:}
	|
		arrayType:at {:
			Type r = new Type(at);
			RESULT = r;
		:}
	;


	// myArray : Array[1..5] of Integer;

	arrayType::= ARRAY LEFT_BRACKET indexRange:ir RIGHT_BRACKET OF simpleType:st {:
			ArrayType r = new ArrayType(ir.start, ir.end, st);
			RESULT = r;
		:}
	;

	// [1..5]

	indexRange::= INTEGER:start DOT DOT INTEGER:end {:
			IndexRange r = new IndexRange((Integer)start, (Integer)end);
			RESULT = r;
		:}
 	;

 	// string, char, integer, boolean

	simpleType::= STRING {:
			SimpleType r = new SimpleType("string");
			RESULT = r;
		:}
	|
		CHAR:st {:
			SimpleType r = new SimpleType("char");
			RESULT = r;
		:}
	|
		INTEGER:st {:
			SimpleType r = new SimpleType("integer");
			RESULT = r;
		:}
	|
		BOOLEAN:st {:
			SimpleType r = new SimpleType("boolean");
			RESULT = r;
		:}
	;

	// para la repeticiÃ³n de statements

	statements::= statement {:

		:}
	|
		statements SEMICOLON statement {:

		:}
	;


	// contiene:
	// if e then s
	// if e then s else s
	// while e do s
	// repeate e until s
	// for id := e to e do s
	// v := e
	// begin ss end

	statement::= IF expression:e THEN statement:s {:
			IfStatement r = new IfStatement(e, s);
			RESULT = r;
		:}
	|
		IF expression:e THEN statement:s1 ELSE statement:s2 {:
			IfStatement r = new IfStatement(e, s1, s2);
			RESULT = r;
		:}
	|
		WHILE expression:e DO statement:s {:
			WhileStatement r = new WhileStatement(e, s);
			RESULT = r;
		:}
	|
		REPEAT statement:e UNTIL expression:e {:
			RepeatStatement r = new RepeatStatement(e, s);
			RESULT = r;
		:}
	|
		FOR ID:id ASIGN expression:e1 TO expression:e2 DO statement:s {:
			ForStatement r = new ForStatement(id, e1, e2, s);
			RESULT = r;
		:}
	|
		variable:v ASIGN expression:e {:
			AssignmentStatement r = new AssignmentStatement(v, e);
			RESULT = r;
		:}
	|
		BEGIN statements:s END {:
			BEStatement r = new BEStatement(s);
			RESULT = r;
		:}
	;

	// agarra el id de una variable normal o el de un arreglo
	// id
	// id[pos]
	// pos puede ser una expresion tipo 4+3

	variable::= ID:id LEFT_BRACKET expression:e RIGHT_BRACKET {:
			Variable r = new Variable(id, e)
			RESULT = r;
		:}
	|
		ID:id {:
			Variable r = new Variable(id);
			RESULT = r;
		:}
	;



	operational::= PRODUCT {:
			Operational r = new Operational("*");
			RESULT = r;
		:}
	|
		DIVIDE {:
			Operational r = new Operational("/");
			RESULT = r;
		:}
	|
		GREATER_THAN {:
			Operational r = new Operational(">");
			RESULT = r;
		:}
	|
		LESS_THAN {:
			Operational r = new Operational("<");
			RESULT = r;
		:}
	|
		GREATER_EQUALS {:
			Operational r = new Operational(">=");
			RESULT = r;
		:}
	|
		LESS_EQUAL {:
			Operational r = new Operational(">=");
			RESULT = r;
		:}
	|
		IN {:
			Operational r = new Operational("IN");
			RESULT = r;
		:}
	|
		{:
			RESULT = null;
		:}
	;


	expression::= simpleExpression:se {:
			Expression r = new Expression(se);
			RESULT = r;
		:}
	|
		simpleExpression:se1 operational:o simpleExpression:se2 {:
			Expression r = new Expression(se1, o, se2);
			RESULT = r;
		:}
	;


	simpleExpression::= PLUS term:t {:
			SimpleExpression r = new SimpleExpression("+", t);
			RESULT = r;
		:}
	|
		MINUS term:t {:
			SimpleExpression r = new SimpleExpression("+", t);
			RESULT = r;
		:}
	|
		term:t {:
			SimpleExpression r = new SimpleExpression(t);
			RESULT = r;
		:}
	|
		simpleExpression:se PLUS term:t {:
			SimpleExpression r = new SimpleExpression(se, "+", t);
			RESULT = t;
		:}
	|
		simpleExpression:se MINUS term:t {:
			SimpleExpression r = new SimpleExpression(se, "-", t);
			RESULT = t;
		:}
	|
		simpleExpression:se OR term:t {:
			SimpleExpression r = new SimpleExpression(se, "OR", t);
			RESULT = t;
		:}
	;


	term::= factor:f {:
			Term r = new Term(f);
			RESULT = r;
		:}
	|
		factor:f termOps:to term:t {:
			Term r = new Term(f,to,t);
			RESULT = r;
		:}
	;

	termOps::= PRODUCT {:
			RESULT = "*";
		:}
	|
		DIVIDE {:
			RESULT = "/";
		:}
	|
		DIV {:
			RESULT = "div";
		:}
	|
		MOD {:
			RESULT = "mod";
		:}
	;

	factor::= variable:v {:
			Factor r = new Factor(v);
			RESULT = r;
		:}
	|
		LEFT_PAR expression:e RIGHT_PAR {:
			Factor r = new Factor(e);
			RESULT = r;
		:}
	|
		NOT factor:f {:
			Factor r = new Factor(f);
			RESULT = r;
		:}
	;
